/*{
    "CREDIT": "Ben Czech + AI co-pilot",
    "DESCRIPTION": "Keep only pixels within a hue band (circular). If hueCenterDeg is out of [0,360] OR hueWidthDeg <= 0, output becomes transparent (no clamp).",
    "CATEGORIES": [ "filter", "keying", "color" ],
    "INPUTS": [
        { "NAME":"inputImage", "TYPE":"image", "LABEL":"Input Image" },

        { "NAME":"hueCenterDeg", "TYPE":"float", "LABEL":"Hue Center (°)", "DEFAULT": 0.0, "MIN": -720.0, "MAX": 720.0 },
        { "NAME":"hueWidthDeg",  "TYPE":"float", "LABEL":"Hue Width (° full band)", "DEFAULT": 40.0, "MIN": -180.0, "MAX": 180.0 },

        { "NAME":"satMin", "TYPE":"float", "LABEL":"Min Saturation", "DEFAULT": 0.15, "MIN": 0.0, "MAX": 1.0 },
        { "NAME":"valMin", "TYPE":"float", "LABEL":"Min Value",      "DEFAULT": 0.10, "MIN": 0.0, "MAX": 1.0 },

        { "NAME":"feather", "TYPE":"float", "LABEL":"Feather (0..0.2)", "DEFAULT": 0.05, "MIN": 0.0, "MAX": 0.3 },

        { "NAME":"invert",      "TYPE":"bool", "LABEL":"Invert Selection",         "DEFAULT": false },
        { "NAME":"maskOnly",    "TYPE":"bool", "LABEL":"Show Mask Only",           "DEFAULT": false },
        { "NAME":"keepSrcAlpha","TYPE":"bool", "LABEL":"Multiply by Source Alpha", "DEFAULT": true }
    ]
}*/

vec3 rgb2hsv(vec3 c) {
    float maxc = max(c.r, max(c.g, c.b));
    float minc = min(c.r, min(c.g, c.b));
    float delta = maxc - minc;

    float h = 0.0;
    if (delta > 1e-6) {
        if (maxc == c.r) {
            h = mod((c.g - c.b) / delta, 6.0);
        } else if (maxc == c.g) {
            h = ((c.b - c.r) / delta) + 2.0;
        } else {
            h = ((c.r - c.g) / delta) + 4.0;
        }
        h /= 6.0;              // 0..6 -> 0..1
        if (h < 0.0) h += 1.0; // wrap
    }
    float s = (maxc <= 0.0) ? 0.0 : (delta / maxc);
    float v = maxc;
    return vec3(h, s, v);
}

// shortest distance on circular hue ring [0,1)
float hueDistance(float h, float center) {
    float d = abs(h - center);
    return min(d, 1.0 - d);
}

void main() {
    vec2 uv = isf_FragNormCoord.xy;
    vec4 src = IMG_NORM_PIXEL(inputImage, uv);

    // If the source is fully transparent, early out
    if (src.a <= 0.0) {
        gl_FragColor = vec4(0.0);
        return;
    }

    // Guard 1: Hue center outside legal domain -> fully transparent (no clamp)
    if (hueCenterDeg < 0.0 || hueCenterDeg > 360.0) {
        float outA = keepSrcAlpha ? (0.0 * src.a) : 0.0;
        gl_FragColor = vec4(0.0, 0.0, 0.0, outA);
        return;
    }

    // Guard 2: Width <= 0 -> fully transparent
    if (hueWidthDeg <= 0.0) {
        float outA = keepSrcAlpha ? (0.0 * src.a) : 0.0;
        gl_FragColor = vec4(0.0, 0.0, 0.0, outA);
        return;
    }

    vec3 hsv = rgb2hsv(src.rgb);

    // Convert degrees to normalized [0..1]; halfWidth max is 0.5 (180°)
    float center = hueCenterDeg / 360.0;             // safe because of guard
    float halfWidth = min(abs(hueWidthDeg) / 360.0, 0.5);

    // Gate out low saturation / low value before hue test
    float gate = 1.0;
    gate *= step(satMin, hsv.y);
    gate *= step(valMin, hsv.z);

    // Circular distance from center and smooth band edge
    float d = hueDistance(hsv.x, center);
    float edge = max(1e-6, feather);                 // avoid degenerate smoothstep
    float band = 1.0 - smoothstep(halfWidth, halfWidth + edge, d);

    float mask = band * gate;
    if (invert) mask = 1.0 - mask;

    // Alpha policy
    float outA = keepSrcAlpha ? (mask * src.a) : mask;

    if (maskOnly) {
        gl_FragColor = vec4(vec3(mask), outA);
    } else {
        gl_FragColor = vec4(src.rgb * mask, outA);
    }
}
